<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#000000">
    <title>SFTi P.R.E.P - OAuth Callback</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            background: linear-gradient(135deg, #1a1a1a 0%, #0a0a0a 100%);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            color: #e0e0e0;
        }

        .container {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .card {
            background: rgba(30, 30, 30, 0.95);
            border: 1px solid rgba(204, 0, 0, 0.3);
            border-radius: 16px;
            padding: 40px;
            max-width: 400px;
            width: 100%;
            text-align: center;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        .logo-container {
            margin-bottom: 24px;
        }

        .logo {
            width: 64px;
            height: 64px;
        }

        h1 {
            font-size: 24px;
            margin-bottom: 8px;
            color: #ffffff;
        }

        .status {
            font-size: 16px;
            margin-bottom: 24px;
            color: #888;
        }

        .status.success {
            color: #00cc66;
        }

        .status.error {
            color: #cc0000;
        }

        .status.processing {
            color: #00bcd4;
        }

        .spinner {
            width: 48px;
            height: 48px;
            border: 3px solid rgba(204, 0, 0, 0.2);
            border-top-color: #cc0000;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 24px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
        }

        .icon.success {
            color: #00cc66;
        }

        .icon.error {
            color: #cc0000;
        }

        .message {
            font-size: 14px;
            color: #888;
            line-height: 1.6;
            margin-bottom: 24px;
        }

        .debug-info {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin-top: 16px;
            font-family: monospace;
            font-size: 11px;
            color: #666;
            text-align: left;
            word-break: break-all;
            max-height: 150px;
            overflow-y: auto;
        }

        .btn {
            display: inline-block;
            background: linear-gradient(135deg, #cc0000 0%, #990000 100%);
            color: white;
            border: none;
            padding: 12px 32px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            text-decoration: none;
            transition: all 0.2s;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(204, 0, 0, 0.4);
        }

        .countdown {
            font-size: 12px;
            color: #666;
            margin-top: 16px;
        }

        /* Hidden states */
        .hidden {
            display: none !important;
        }
    </style>
    <!-- Load CORS bypass widget for OAuth proxy -->
    <script src="../../js.on/cors-bypass.js"></script>
</head>
<body>
    <div class="container">
        <div class="card">
            <!-- Logo -->
            <div class="logo-container">
                <svg class="logo" viewBox="0 0 285 285" xmlns="http://www.w3.org/2000/svg">
                    <rect x="0" y="0" width="285" height="285" rx="64" fill="#C0392B"/>
                    <path d="M30 84 L60 94 L90 89 L120 79 L150 99 L180 94 L210 89 L240 84 L255 86" stroke="#FFA500" stroke-width="3" stroke-dasharray="6 4" fill="none" opacity="0.8"/>
                    <rect x="33" y="104" width="12" height="36" fill="white"/>
                    <line x1="39" y1="94" x2="39" y2="104" stroke="white" stroke-width="2.5"/>
                    <line x1="39" y1="140" x2="39" y2="150" stroke="white" stroke-width="2.5"/>
                    <rect x="58" y="114" width="12" height="28" fill="#212121"/>
                    <line x1="64" y1="102" x2="64" y2="114" stroke="#212121" stroke-width="2.5"/>
                    <line x1="64" y1="142" x2="64" y2="154" stroke="#212121" stroke-width="2.5"/>
                    <rect x="83" y="99" width="12" height="42" fill="white"/>
                    <line x1="89" y1="88" x2="89" y2="99" stroke="white" stroke-width="2.5"/>
                    <line x1="89" y1="141" x2="89" y2="152" stroke="white" stroke-width="2.5"/>
                    <rect x="108" y="74" width="12" height="52" fill="white"/>
                    <line x1="114" y1="62" x2="114" y2="74" stroke="white" stroke-width="2.5"/>
                    <line x1="114" y1="126" x2="114" y2="138" stroke="white" stroke-width="2.5"/>
                    <rect x="133" y="94" width="12" height="38" fill="#212121"/>
                    <line x1="139" y1="82" x2="139" y2="94" stroke="#212121" stroke-width="2.5"/>
                    <line x1="139" y1="132" x2="139" y2="144" stroke="#212121" stroke-width="2.5"/>
                    <rect x="158" y="109" width="12" height="30" fill="#212121"/>
                    <line x1="164" y1="97" x2="164" y2="109" stroke="#212121" stroke-width="2.5"/>
                    <line x1="164" y1="139" x2="164" y2="151" stroke="#212121" stroke-width="2.5"/>
                    <rect x="183" y="102" width="12" height="34" fill="white"/>
                    <line x1="189" y1="90" x2="189" y2="102" stroke="white" stroke-width="2.5"/>
                    <line x1="189" y1="136" x2="189" y2="148" stroke="white" stroke-width="2.5"/>
                    <rect x="208" y="80" width="12" height="48" fill="white"/>
                    <line x1="214" y1="68" x2="214" y2="80" stroke="white" stroke-width="2.5"/>
                    <line x1="214" y1="128" x2="214" y2="148" stroke="white" stroke-width="2.5"/>
                    <rect x="233" y="60" width="12" height="44" fill="white"/>
                    <line x1="239" y1="46" x2="239" y2="60" stroke="white" stroke-width="2.5"/>
                    <line x1="239" y1="104" x2="239" y2="110" stroke="white" stroke-width="2.5"/>
                    <path d="M15 174H270" stroke="white" stroke-width="4" stroke-linecap="round"/>
                    <path d="M39 174V190L24 205" stroke="white" stroke-width="2.5" stroke-linecap="round" fill="none"/>
                    <circle cx="24" cy="205" r="4" fill="white"/>
                    <path d="M64 174V198L49 213" stroke="white" stroke-width="2.5" stroke-linecap="round" fill="none"/>
                    <circle cx="49" cy="213" r="4" fill="white"/>
                    <path d="M89 174V205" stroke="white" stroke-width="2.5" stroke-linecap="round" fill="none"/>
                    <circle cx="89" cy="205" r="4" fill="white"/>
                    <path d="M114 174V198L129 213" stroke="white" stroke-width="2.5" stroke-linecap="round" fill="none"/>
                    <circle cx="129" cy="213" r="4" fill="white"/>
                    <path d="M139 174V190L154 205" stroke="white" stroke-width="2.5" stroke-linecap="round" fill="none"/>
                    <circle cx="154" cy="205" r="4" fill="white"/>
                    <path d="M164 174V205" stroke="white" stroke-width="2.5" stroke-linecap="round" fill="none"/>
                    <circle cx="164" cy="205" r="4" fill="white"/>
                    <path d="M189 174V190L204 205" stroke="white" stroke-width="2.5" stroke-linecap="round" fill="none"/>
                    <circle cx="204" cy="205" r="4" fill="white"/>
                    <path d="M214 174V198L229 213" stroke="white" stroke-width="2.5" stroke-linecap="round" fill="none"/>
                    <circle cx="229" cy="213" r="4" fill="white"/>
                    <path d="M239 174V190L254 205" stroke="white" stroke-width="2.5" stroke-linecap="round" fill="none"/>
                    <circle cx="254" cy="205" r="4" fill="white"/>
                </svg>
            </div>

            <h1>SFTi P.R.E.P</h1>

            <!-- Processing State -->
            <div id="state-processing">
                <div class="spinner"></div>
                <p class="status processing">Processing OAuth...</p>
                <p class="message">Please wait while we complete authentication.</p>
            </div>

            <!-- Success State -->
            <div id="state-success" class="hidden">
                <svg class="icon success" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"/>
                    <path d="M9 12l2 2 4-4"/>
                </svg>
                <p class="status success">Authentication Successful!</p>
                <p class="message">Your GitHub Copilot access has been configured. You can now use all available AI models.</p>
                <a href="../../index.html" class="btn">Return to App</a>
                <p class="countdown">Redirecting in <span id="countdown">5</span> seconds...</p>
            </div>

            <!-- Error State -->
            <div id="state-error" class="hidden">
                <svg class="icon error" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"/>
                    <path d="M15 9l-6 6M9 9l6 6"/>
                </svg>
                <p class="status error">Authentication Failed</p>
                <p class="message" id="error-message">An error occurred during authentication.</p>
                <a href="../../index.html" class="btn">Return to App</a>
                <div class="debug-info" id="debug-info"></div>
            </div>

            <!-- No Code State -->
            <div id="state-no-code" class="hidden">
                <svg class="icon" style="color: #888;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"/>
                    <path d="M12 8v4M12 16h.01"/>
                </svg>
                <p class="status">No Authorization Code</p>
                <p class="message">No OAuth authorization code was found. Please start the authentication process from the app.</p>
                <a href="../../index.html" class="btn">Go to App</a>
            </div>
        </div>
    </div>

    <script>
        /**
         * SFTi P.R.E.P - Static OAuth Callback Handler
         * 
         * This file handles the OAuth callback for GitHub authentication.
         * It's designed to work entirely client-side on GitHub Pages.
         * 
         * IMPORTANT: OAuth Web Flow has CORS limitations on GitHub Pages.
         * We STRONGLY RECOMMEND using Device Flow instead (no callback needed).
         * 
         * The flow:
         * 1. User clicks "Connect with GitHub" in the main app
         * 2. User is redirected to GitHub's OAuth authorization page
         * 3. After authorization, GitHub redirects back here with a code
         * 4. We attempt to exchange code for token (may fail due to CORS)
         * 5. Token is stored and user is redirected back to the app
         * 
         * NOTE: This callback is primarily for compatibility.
         * For better experience, use Device Flow which doesn't require this page.
         */

        // Note: CORS limitations mean token exchange often fails here
        // Device Flow is the recommended authentication method

        const OAuthCallbackHandler = {
            // Configuration
            config: {
                // Storage keys
                STORAGE_KEYS: {
                    PENDING_STATE: 'oauth_pending_state',
                    COPILOT_TOKEN: 'copilotToken',
                    COPILOT_EXPIRY: 'copilotTokenExpiry',
                    GITHUB_TOKEN: 'githubToken',
                    OAUTH_STATE: 'oauth_state',
                    DEVICE_CODE: 'device_code_data'
                },
                
                // GitHub OAuth endpoints
                TOKEN_URL: 'https://github.com/login/oauth/access_token',
                
                // Redirect delay after success
                REDIRECT_DELAY: 5000,
                
                // Main app URL
                APP_URL: '../../index.html'
            },

            // State management
            setState(state) {
                document.getElementById('state-processing').classList.add('hidden');
                document.getElementById('state-success').classList.add('hidden');
                document.getElementById('state-error').classList.add('hidden');
                document.getElementById('state-no-code').classList.add('hidden');
                document.getElementById(`state-${state}`).classList.remove('hidden');
            },

            // Show success state with countdown
            showSuccess(token, tokenType = 'copilot') {
                this.setState('success');
                
                // Store token
                if (tokenType === 'copilot') {
                    localStorage.setItem(this.config.STORAGE_KEYS.COPILOT_TOKEN, token);
                    // Set expiry to 8 hours from now (GitHub Copilot tokens)
                    const expiry = Date.now() + (8 * 60 * 60 * 1000);
                    localStorage.setItem(this.config.STORAGE_KEYS.COPILOT_EXPIRY, expiry.toString());
                } else {
                    localStorage.setItem(this.config.STORAGE_KEYS.GITHUB_TOKEN, token);
                }
                
                // Broadcast to other tabs via BroadcastChannel
                if ('BroadcastChannel' in window) {
                    const channel = new BroadcastChannel('sfti-backend');
                    channel.postMessage({
                        type: 'TOKEN_UPDATE',
                        tokenType: tokenType,
                        token: token
                    });
                    channel.close();
                }
                
                // Notify opener window if exists (popup flow)
                if (window.opener && !window.opener.closed) {
                    window.opener.postMessage({
                        type: 'OAUTH_SUCCESS',
                        token: token,
                        tokenType: tokenType
                    }, '*');
                }
                
                // Clear pending OAuth state
                localStorage.removeItem(this.config.STORAGE_KEYS.PENDING_STATE);
                localStorage.removeItem(this.config.STORAGE_KEYS.OAUTH_STATE);
                localStorage.removeItem(this.config.STORAGE_KEYS.DEVICE_CODE);
                
                // Start countdown and redirect
                this.startCountdown();
            },

            // Show error state
            showError(message, debugData = null) {
                this.setState('error');
                document.getElementById('error-message').textContent = message;
                
                if (debugData) {
                    const debugEl = document.getElementById('debug-info');
                    debugEl.textContent = typeof debugData === 'string' 
                        ? debugData 
                        : JSON.stringify(debugData, null, 2);
                    debugEl.classList.remove('hidden');
                }
                
                // Notify opener window if exists
                if (window.opener && !window.opener.closed) {
                    window.opener.postMessage({
                        type: 'OAUTH_ERROR',
                        error: message
                    }, '*');
                }
            },

            // Countdown timer for redirect
            startCountdown() {
                let seconds = 5;
                const countdownEl = document.getElementById('countdown');
                
                const timer = setInterval(() => {
                    seconds--;
                    countdownEl.textContent = seconds;
                    
                    if (seconds <= 0) {
                        clearInterval(timer);
                        this.redirect();
                    }
                }, 1000);
            },

            // Redirect to main app
            redirect() {
                // Close popup if in popup mode
                if (window.opener && !window.opener.closed) {
                    window.close();
                } else {
                    window.location.href = this.config.APP_URL;
                }
            },

            // Parse URL parameters
            getURLParams() {
                const params = new URLSearchParams(window.location.search);
                const hashParams = new URLSearchParams(window.location.hash.substring(1));
                
                return {
                    code: params.get('code') || hashParams.get('code'),
                    state: params.get('state') || hashParams.get('state'),
                    error: params.get('error') || hashParams.get('error'),
                    error_description: params.get('error_description') || hashParams.get('error_description'),
                    access_token: hashParams.get('access_token'),
                    token_type: hashParams.get('token_type')
                };
            },

            // Validate state parameter (CSRF protection)
            validateState(receivedState) {
                const storedState = localStorage.getItem(this.config.STORAGE_KEYS.OAUTH_STATE);
                
                if (!storedState) {
                    console.warn('No stored state found');
                    return true; // Allow if no state stored (first time use)
                }
                
                return receivedState === storedState;
            },

            // Wait for CustomCorsWidget to be ready
            async waitForCorsWidget(timeout = 10000) {
                const startTime = Date.now();
                while (Date.now() - startTime < timeout) {
                    if (window.CustomCorsWidget && window.CustomCorsWidget.initialized) {
                        console.log('[Callback] CustomCorsWidget is ready!');
                        return window.CustomCorsWidget;
                    }
                    // Wait 100ms before checking again
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                console.warn('[Callback] CustomCorsWidget initialization timeout after', timeout, 'ms');
                return null;
            },

            // Exchange authorization code for token
            // Uses our self-hosted CORS bypass proxy system
            async exchangeCodeForToken(code) {
                // Get stored OAuth app credentials
                const clientId = localStorage.getItem('oauth_client_id');
                const clientSecret = localStorage.getItem('oauth_client_secret');
                
                if (!clientId) {
                    throw new Error('OAuth Client ID not configured. Please set up your GitHub OAuth App credentials in the main application.');
                }
                
                if (!clientSecret) {
                    throw new Error('OAuth Client Secret not configured. GitHub OAuth Web Flow requires both Client ID and Client Secret.');
                }
                
                console.log('[Callback] Exchanging code for token using self-hosted proxy...');
                
                const tokenExchangeParams = new URLSearchParams({
                    client_id: clientId,
                    client_secret: clientSecret,
                    code: code,
                    redirect_uri: window.location.origin + window.location.pathname
                });
                
                // Strategy 1: Wait for and try using CustomCorsWidget
                try {
                    console.log('[Callback] Waiting for CustomCorsWidget to initialize...');
                    const corsWidget = await this.waitForCorsWidget(10000);
                    
                    if (corsWidget && typeof corsWidget.fetch === 'function') {
                        console.log('[Callback] Using CustomCorsWidget proxy...');
                        const response = await corsWidget.fetch(this.config.TOKEN_URL, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/x-www-form-urlencoded',
                                'Accept': 'application/json'
                            },
                            body: tokenExchangeParams.toString()
                        });
                        
                        if (response && response.ok) {
                            const tokenData = await response.json();
                            console.log('[Callback] Token exchange successful via CustomCorsWidget!');
                            return tokenData;
                        } else {
                            console.warn('[Callback] CustomCorsWidget fetch returned non-OK response:', response ? response.status : 'null response');
                        }
                    } else {
                        console.warn('[Callback] CustomCorsWidget not available or fetch method missing');
                    }
                } catch (error) {
                    console.warn('[Callback] CustomCorsWidget strategy failed:', error);
                }
                
                // Strategy 2: Try JSONP approach for GET fallback
                try {
                    console.log('[Callback] Trying JSONP fallback...');
                    const jsonpUrl = `${this.config.TOKEN_URL}?${tokenExchangeParams.toString()}`;
                    const tokenData = await this.jsonpFetch(jsonpUrl);
                    if (tokenData && tokenData.access_token) {
                        console.log('[Callback] Token exchange successful via JSONP!');
                        return tokenData;
                    }
                } catch (error) {
                    console.warn('[Callback] JSONP strategy failed:', error);
                }
                
                // Strategy 3: Try using Service Worker proxy
                try {
                    console.log('[Callback] Trying Service Worker proxy...');
                    if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
                        const response = await fetch(this.config.TOKEN_URL, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/x-www-form-urlencoded',
                                'Accept': 'application/json',
                                'X-Cors-Proxy': 'true' // Marker for service worker
                            },
                            body: tokenExchangeParams.toString()
                        });
                        
                        if (response.ok) {
                            const tokenData = await response.json();
                            console.log('[Callback] Token exchange successful via Service Worker!');
                            return tokenData;
                        }
                    }
                } catch (error) {
                    console.warn('[Callback] Service Worker strategy failed:', error);
                }
                
                // Strategy 4: Try iframe proxy
                try {
                    console.log('[Callback] Trying iframe proxy...');
                    const tokenData = await this.iframeProxyFetch(this.config.TOKEN_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                            'Accept': 'application/json'
                        },
                        body: tokenExchangeParams.toString()
                    });
                    
                    if (tokenData && tokenData.access_token) {
                        console.log('[Callback] Token exchange successful via iframe proxy!');
                        return tokenData;
                    }
                } catch (error) {
                    console.warn('[Callback] Iframe proxy strategy failed:', error);
                }
                
                // All strategies failed
                throw new Error(
                    `All OAuth proxy strategies failed. ` +
                    `For better reliability, please use Device Flow authentication ` +
                    `which doesn't require a callback URL or token exchange.`
                );
            },
            
            // JSONP fetch helper
            jsonpFetch(url, timeout = 10000) {
                return new Promise((resolve, reject) => {
                    const callbackName = 'jsonp_callback_' + Math.random().toString(36).substring(7);
                    const script = document.createElement('script');
                    const timer = setTimeout(() => {
                        cleanup();
                        reject(new Error('JSONP request timeout'));
                    }, timeout);
                    
                    const cleanup = () => {
                        clearTimeout(timer);
                        if (script.parentNode) {
                            script.parentNode.removeChild(script);
                        }
                        delete window[callbackName];
                    };
                    
                    window[callbackName] = (data) => {
                        cleanup();
                        resolve(data);
                    };
                    
                    script.onerror = () => {
                        cleanup();
                        reject(new Error('JSONP script load error'));
                    };
                    
                    script.src = url + (url.includes('?') ? '&' : '?') + 'callback=' + callbackName;
                    document.head.appendChild(script);
                });
            },
            
            // Iframe proxy helper
            iframeProxyFetch(url, options) {
                return new Promise((resolve, reject) => {
                    const iframe = document.createElement('iframe');
                    iframe.style.display = 'none';
                    iframe.sandbox = 'allow-scripts allow-same-origin'; // Need same-origin for postMessage
                    
                    const timer = setTimeout(() => {
                        cleanup();
                        reject(new Error('Iframe proxy timeout'));
                    }, 15000);
                    
                    const cleanup = () => {
                        clearTimeout(timer);
                        window.removeEventListener('message', messageHandler);
                        if (iframe.parentNode) {
                            iframe.parentNode.removeChild(iframe);
                        }
                    };
                    
                    const messageHandler = (event) => {
                        if (event.source !== iframe.contentWindow) return;
                        
                        if (event.data.type === 'FETCH_SUCCESS') {
                            cleanup();
                            resolve(event.data.data);
                        } else if (event.data.type === 'FETCH_ERROR') {
                            cleanup();
                            reject(new Error(event.data.error));
                        }
                    };
                    
                    window.addEventListener('message', messageHandler);
                    
                    // Create iframe content that performs the fetch
                    const iframeHtml = `
                        <!DOCTYPE html>
                        <html>
                        <head><meta charset="utf-8"></head>
                        <body>
                        <script>
                            (async function() {
                                try {
                                    const response = await fetch('${url}', ${JSON.stringify(options)});
                                    const data = await response.json();
                                    parent.postMessage({ type: 'FETCH_SUCCESS', data: data }, '*');
                                } catch (error) {
                                    parent.postMessage({ type: 'FETCH_ERROR', error: error.message }, '*');
                                }
                            })();
                        </script>
                        </body>
                        </html>
                    `;
                    
                    iframe.srcdoc = iframeHtml;
                    document.body.appendChild(iframe);
                });
            },

            // Handle implicit grant flow (token in URL hash)
            handleImplicitGrant(accessToken, tokenType) {
                console.log('Handling implicit grant token');
                this.showSuccess(accessToken, 'copilot');
            },

            // Handle authorization code flow
            async handleCodeFlow(code, state) {
                console.log('Handling authorization code flow');
                
                // Validate state
                if (state && !this.validateState(state)) {
                    this.showError('Invalid state parameter. This could be a CSRF attack.', { 
                        received: state,
                        expected: localStorage.getItem(this.config.STORAGE_KEYS.OAUTH_STATE)
                    });
                    return;
                }
                
                try {
                    const tokenData = await this.exchangeCodeForToken(code);
                    
                    if (tokenData.access_token) {
                        this.showSuccess(tokenData.access_token, 'copilot');
                    } else if (tokenData.error) {
                        this.showError(
                            tokenData.error_description || tokenData.error,
                            tokenData
                        );
                    } else {
                        this.showError(
                            'Failed to obtain access token',
                            tokenData
                        );
                    }
                } catch (error) {
                    this.showError(error.message, { 
                        code: code.substring(0, 10) + '...',
                        error: error.toString()
                    });
                }
            },

            // Main initialization
            async init() {
                console.log('OAuth Callback Handler initializing...');
                
                const params = this.getURLParams();
                
                // Handle errors from GitHub
                if (params.error) {
                    this.showError(
                        params.error_description || params.error,
                        { error: params.error, description: params.error_description }
                    );
                    return;
                }
                
                // Handle implicit grant (token in URL hash)
                if (params.access_token) {
                    this.handleImplicitGrant(params.access_token, params.token_type);
                    return;
                }
                
                // Handle authorization code flow
                if (params.code) {
                    await this.handleCodeFlow(params.code, params.state);
                    return;
                }
                
                // No code or token found
                this.setState('no-code');
            }
        };

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            OAuthCallbackHandler.init();
        });

        // Handle messages from opener window (for token exchange)
        window.addEventListener('message', (event) => {
            // Verify origin for security
            if (!event.origin.includes('github.io') && !event.origin.includes('localhost')) {
                return;
            }
            
            if (event.data.type === 'CHECK_CALLBACK') {
                // Opener is checking if we're ready
                event.source.postMessage({ type: 'CALLBACK_READY' }, event.origin);
            }
        });
    </script>
</body>
</html>
