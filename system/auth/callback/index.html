<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#000000">
    <title>SFTi P.R.E.P - OAuth Callback</title>
    
    <!-- Infrastructure Scripts - Load synchronously in head -->
    <script src="../../js.on/cors-bypass.js"></script>
    
    <!-- Pre-initialize infrastructure before DOM loads -->
    <script>
        // Verbose logging starts IMMEDIATELY
        const BootLogger = {
            logs: [],
            log(level, emoji, message, data = null) {
                const timestamp = new Date().toLocaleTimeString('en-US', { 
                    hour12: false,
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    fractionalSecondDigits: 3
                });
                
                const logEntry = {
                    timestamp,
                    level,
                    emoji,
                    message,
                    data
                };
                
                this.logs.push(logEntry);
                console.log(`[${timestamp}] ${emoji} ${message}`, data || '');
            }
        };
        
        BootLogger.log('info', '‚ö°', 'BOOT SEQUENCE STARTED');
        BootLogger.log('info', 'üì¶', 'Loading CORS bypass infrastructure...');
        
        // Check if CustomCorsWidget loaded
        if (typeof window.CustomCorsWidget !== 'undefined') {
            BootLogger.log('success', '‚úÖ', 'CustomCorsWidget class loaded successfully');
            
            // Start infrastructure initialization IMMEDIATELY
            BootLogger.log('info', 'üöÄ', 'Starting infrastructure pre-initialization...');
            
            window.CustomCorsWidget.init().then(() => {
                BootLogger.log('success', '‚úÖ', 'Infrastructure pre-initialization COMPLETE');
                BootLogger.log('info', 'üì°', 'Proxy servers activated and ready');
                window.INFRASTRUCTURE_READY = true;
            }).catch(error => {
                BootLogger.log('error', '‚ùå', 'Infrastructure pre-initialization FAILED', error.message);
                window.INFRASTRUCTURE_READY = false;
            });
        } else {
            BootLogger.log('error', '‚ùå', 'CustomCorsWidget class NOT FOUND - critical infrastructure failure');
            window.INFRASTRUCTURE_READY = false;
        }
        
        // Store boot logs for later display in terminal
        window.BOOT_LOGS = BootLogger.logs;
    </script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            background: linear-gradient(135deg, #1a1a1a 0%, #0a0a0a 100%);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            color: #e0e0e0;
        }

        .container {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            gap: 0;
        }

        /* OAuth Status Card */
        .oauth-card {
            background: rgba(30, 30, 30, 0.95);
            border: 1px solid rgba(204, 0, 0, 0.3);
            border-radius: 16px 16px 0 0;
            padding: 40px;
            max-width: 700px;
            width: 100%;
            text-align: center;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        .logo-container {
            margin-bottom: 24px;
        }

        .logo {
            width: 64px;
            height: 64px;
        }

        h1 {
            font-size: 24px;
            margin-bottom: 8px;
            color: #ffffff;
        }

        .status {
            font-size: 16px;
            margin-bottom: 24px;
            color: #888;
        }

        .status.success {
            color: #00cc66;
        }

        .status.error {
            color: #cc0000;
        }

        .status.processing {
            color: #00bcd4;
        }

        .spinner {
            width: 48px;
            height: 48px;
            border: 3px solid rgba(204, 0, 0, 0.2);
            border-top-color: #cc0000;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 24px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .message {
            font-size: 14px;
            line-height: 1.6;
            color: #aaa;
            margin-bottom: 24px;
        }

        .hidden {
            display: none !important;
        }

        .btn {
            display: inline-block;
            background: #cc0000;
            color: white;
            text-decoration: none;
            padding: 12px 32px;
            border-radius: 8px;
            font-weight: 600;
            transition: all 0.3s;
        }

        .btn:hover {
            background: #aa0000;
            transform: translateY(-2px);
        }

        /* Debug Terminal - Attached to OAuth Card */
        .debug-terminal {
            background: rgba(10, 10, 10, 0.98);
            border: 1px solid rgba(204, 0, 0, 0.3);
            border-top: 3px solid #cc0000;
            border-radius: 0 0 16px 16px;
            max-width: 700px;
            width: 100%;
            height: 500px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        .terminal-header {
            background: rgba(204, 0, 0, 0.15);
            padding: 14px 20px;
            border-bottom: 1px solid rgba(204, 0, 0, 0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        .terminal-title {
            color: #cc0000;
            font-weight: bold;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 10px;
            font-family: 'Courier New', monospace;
        }

        .terminal-title::before {
            content: "‚ö°";
            font-size: 18px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .terminal-status {
            font-family: 'Courier New', monospace;
            font-size: 11px;
            color: #666;
        }

        .terminal-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 16px;
            background: rgba(0, 0, 0, 0.7);
            font-family: 'Courier New', 'Consolas', 'Monaco', monospace;
            font-size: 13px;
            line-height: 1.6;
        }

        /* Custom scrollbar */
        .terminal-content::-webkit-scrollbar {
            width: 8px;
        }

        .terminal-content::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
        }

        .terminal-content::-webkit-scrollbar-thumb {
            background: rgba(204, 0, 0, 0.5);
            border-radius: 4px;
        }

        .terminal-content::-webkit-scrollbar-thumb:hover {
            background: rgba(204, 0, 0, 0.7);
        }

        .terminal-line {
            margin: 4px 0;
            padding: 6px 10px;
            border-left: 3px solid transparent;
            word-wrap: break-word;
            white-space: pre-wrap;
        }

        .terminal-line.info {
            color: #00bcd4;
            border-left-color: #00bcd4;
            background: rgba(0, 188, 212, 0.05);
        }

        .terminal-line.success {
            color: #00cc66;
            border-left-color: #00cc66;
            background: rgba(0, 204, 102, 0.05);
            font-weight: bold;
        }

        .terminal-line.error {
            color: #ff4444;
            border-left-color: #ff4444;
            background: rgba(255, 68, 68, 0.1);
            font-weight: bold;
        }

        .terminal-line.warning {
            color: #ff9800;
            border-left-color: #ff9800;
            background: rgba(255, 152, 0, 0.05);
        }

        .terminal-line.debug {
            color: #888;
            border-left-color: #444;
            font-size: 12px;
        }

        .terminal-timestamp {
            color: #666;
            font-size: 11px;
            margin-right: 8px;
        }

        .terminal-emoji {
            margin-right: 6px;
        }

        .countdown {
            font-size: 12px;
            color: #666;
            margin-top: 16px;
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
        }

        .icon.success {
            color: #00cc66;
        }

        .icon.error {
            color: #cc0000;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- OAuth Status Card -->
        <div class="oauth-card">
            <div class="logo-container">
                <svg class="logo" viewBox="0 0 100 100" fill="none">
                    <rect width="100" height="100" rx="20" fill="#cc0000"/>
                    <path d="M30 50 L45 65 L70 35" stroke="white" stroke-width="8" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            </div>
            <h1>SFTi P.R.E.P</h1>

            <!-- Processing State -->
            <div id="state-processing">
                <div class="spinner"></div>
                <p class="status processing">Processing OAuth...</p>
                <p class="message">Please wait while we complete authentication.</p>
            </div>

            <!-- Success State -->
            <div id="state-success" class="hidden">
                <svg class="icon success" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"/>
                    <path d="M9 12l2 2 4-4"/>
                </svg>
                <p class="status success">Authentication Successful!</p>
                <p class="message">Your GitHub Copilot access has been configured.</p>
                <a href="../../index.html" class="btn">Return to App</a>
                <p class="countdown">Redirecting in <span id="countdown">5</span> seconds...</p>
            </div>

            <!-- Error State -->
            <div id="state-error" class="hidden">
                <svg class="icon error" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"/>
                    <path d="M15 9l-6 6M9 9l6 6"/>
                </svg>
                <p class="status error">Authentication Failed</p>
                <p class="message" id="error-message">An error occurred during authentication.</p>
                <a href="../../index.html" class="btn">Return to App</a>
            </div>

            <!-- No Code State -->
            <div id="state-no-code" class="hidden">
                <svg class="icon" style="color: #888;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"/>
                    <path d="M12 8v4M12 16h.01"/>
                </svg>
                <p class="status">No Authorization Code</p>
                <p class="message">No OAuth authorization code found. Please start authentication from the app.</p>
                <a href="../../index.html" class="btn">Go to App</a>
            </div>
        </div>

        <!-- Debug Terminal - Attached Below OAuth Card -->
        <div class="debug-terminal">
            <div class="terminal-header">
                <div class="terminal-title">VERBOSE DEBUG TERMINAL - OAuth Runtime Monitor</div>
                <div class="terminal-status">LIVE | <span id="log-count">0</span> messages</div>
            </div>
            <div class="terminal-content" id="terminal-content">
                <!-- Log messages appear here -->
            </div>
        </div>
    </div>

    <script>
        /**
         * Verbose Debug Terminal - Real-Time OAuth Flow Monitor
         * Shows ACTUAL error messages and runtime feed
         */
        const Terminal = {
            count: 0,
            
            log(level, emoji, message, data = null) {
                this.count++;
                const countEl = document.getElementById('log-count');
                if (countEl) {
                    countEl.textContent = this.count;
                }
                
                const timestamp = new Date().toLocaleTimeString('en-US', { 
                    hour12: false,
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    fractionalSecondDigits: 3
                });
                
                const content = document.getElementById('terminal-content');
                if (!content) return;
                
                const line = document.createElement('div');
                line.className = `terminal-line ${level}`;
                
                let text = `<span class="terminal-timestamp">[${timestamp}]</span>`;
                text += `<span class="terminal-emoji">${emoji}</span>`;
                text += message;
                
                if (data !== null && data !== undefined) {
                    if (typeof data === 'object') {
                        text += `\n${JSON.stringify(data, null, 2)}`;
                    } else {
                        text += `\n${data}`;
                    }
                }
                
                line.innerHTML = text;
                content.appendChild(line);
                
                // Auto-scroll to bottom
                content.scrollTop = content.scrollHeight;
                
                // Also log to browser console
                console.log(`[${level.toUpperCase()}] ${message}`, data || '');
            },
            
            info(message, data) {
                this.log('info', 'üì°', message, data);
            },
            
            success(message, data) {
                this.log('success', '‚úÖ', message, data);
            },
            
            error(message, data) {
                this.log('error', '‚ùå', message, data);
            },
            
            warning(message, data) {
                this.log('warning', '‚ö†Ô∏è', message, data);
            },
            
            debug(message, data) {
                this.log('debug', 'üîç', message, data);
            },
            
            /**
             * Display boot logs that happened before terminal was ready
             */
            displayBootLogs() {
                if (window.BOOT_LOGS && Array.isArray(window.BOOT_LOGS)) {
                    this.info('üìú Replaying boot sequence logs...');
                    window.BOOT_LOGS.forEach(logEntry => {
                        this.log(logEntry.level, logEntry.emoji, logEntry.message, logEntry.data);
                    });
                    this.info('üìú Boot sequence replay complete');
                }
            }
        };

        /**
         * OAuth Callback Handler with Verbose Logging
         */
        const OAuthHandler = {
            config: {
                TOKEN_URL: 'https://github.com/login/oauth/access_token',
                CLIENT_ID: window.localStorage.getItem('oauth_client_id') || '',
                CLIENT_SECRET: window.localStorage.getItem('oauth_client_secret') || '',
                REDIRECT_URI: window.location.origin + window.location.pathname.replace(/\/+$/, '')
            },
            
            async init() {
                // Display boot logs first
                Terminal.displayBootLogs();
                
                Terminal.info('üöÄ OAuth Callback Handler initializing...');
                Terminal.debug('Current URL', window.location.href);
                Terminal.debug('Origin', window.location.origin);
                Terminal.debug('Pathname', window.location.pathname);
                
                // Check infrastructure status
                Terminal.info('üîç Checking infrastructure status...');
                Terminal.debug('CustomCorsWidget present', !!window.CustomCorsWidget);
                Terminal.debug('Infrastructure ready flag', !!window.INFRASTRUCTURE_READY);
                
                if (!window.CustomCorsWidget) {
                    Terminal.error('üö´ CRITICAL: CustomCorsWidget not loaded');
                    Terminal.error('Infrastructure failed to load - cannot proceed');
                    this.showError('Infrastructure initialization failed. Please refresh the page.');
                    return;
                }
                
                Terminal.success('CustomCorsWidget loaded successfully');
                
                // Check if infrastructure is ready
                if (!window.INFRASTRUCTURE_READY) {
                    Terminal.warning('Infrastructure still initializing, waiting...');
                    
                    // Use Promise.race for more efficient waiting
                    const maxWait = 15000;
                    const waitPromise = new Promise((resolve, reject) => {
                        const checkInterval = 500;
                        let waited = 0;
                        
                        const intervalId = setInterval(() => {
                            if (window.INFRASTRUCTURE_READY) {
                                clearInterval(intervalId);
                                resolve();
                            } else {
                                waited += checkInterval;
                                if (waited % 2000 === 0) {
                                    Terminal.info(`‚è≥ Still waiting for infrastructure... (${waited/1000}s)`);
                                }
                                if (waited >= maxWait) {
                                    clearInterval(intervalId);
                                    reject(new Error('Infrastructure initialization timeout'));
                                }
                            }
                        }, checkInterval);
                    });
                    
                    try {
                        await waitPromise;
                    } catch (error) {
                        Terminal.error('‚ùå Infrastructure initialization timeout after 15s');
                        this.showError('Infrastructure failed to initialize in time. Please try again.');
                        return;
                    }
                }
                
                Terminal.success('‚úÖ Infrastructure is READY and OPERATIONAL');
                
                // Display infrastructure details
                if (window.CustomCorsWidget) {
                    const widget = window.CustomCorsWidget;
                    Terminal.info('üìä Infrastructure Status Report:');
                    Terminal.debug('  - Initialized', widget.state.initialized);
                    Terminal.debug('  - Service Worker', widget.state.serviceWorkerReady ? 'READY' : 'NOT READY');
                    Terminal.debug('  - Proxy Servers', widget.state.proxyServers.size + ' loaded');
                    Terminal.debug('  - Proxy Workers', widget.state.proxyWorkers.length + ' active');
                    Terminal.debug('  - Vault Database', widget.state.vaultDb ? 'READY' : 'NOT READY');
                    Terminal.debug('  - Keypair', widget.config.keypair ? 'GENERATED' : 'NOT GENERATED');
                    Terminal.debug('  - WebRTC Channels', widget.state.webrtcChannels.size + ' active');
                    
                    // List available proxy servers
                    if (widget.state.proxyServers.size > 0) {
                        Terminal.info('üåê Available Proxy Servers:');
                        for (const [name, proxy] of widget.state.proxyServers) {
                            Terminal.debug(`  - ${name}`, proxy.name || name);
                        }
                    }
                }
                
                // Get URL parameters
                const params = new URLSearchParams(window.location.search);
                const code = params.get('code');
                const state = params.get('state');
                const error = params.get('error');
                const error_description = params.get('error_description');
                
                Terminal.info('URL Parameters parsed');
                Terminal.debug('Code', code ? code.substring(0, 15) + '...' : 'MISSING');
                Terminal.debug('State', state || 'null');
                Terminal.debug('Error', error || 'null');
                
                // Handle GitHub errors
                if (error) {
                    Terminal.error('GitHub returned error', {
                        error: error,
                        description: error_description
                    });
                    this.showError(error_description || error);
                    return;
                }
                
                // Handle no code
                if (!code) {
                    Terminal.warning('No authorization code in URL');
                    this.showState('no-code');
                    return;
                }
                
                Terminal.success('Authorization code detected - starting token exchange');
                
                // Validate state (CSRF protection)
                const expectedState = localStorage.getItem('oauth_state');
                if (state !== expectedState) {
                    Terminal.error('State validation FAILED - possible CSRF attack', {
                        received: state,
                        expected: expectedState
                    });
                    this.showError('Invalid state parameter. Possible CSRF attack.');
                    return;
                }
                Terminal.success('State validation passed');
                
                // Load client credentials
                Terminal.info('Loading OAuth client credentials...');
                const clientId = localStorage.getItem('oauth_client_id');
                const clientSecret = localStorage.getItem('oauth_client_secret');
                
                if (!clientId) {
                    Terminal.error('Client ID not found in localStorage');
                    this.showError('OAuth client ID not configured');
                    return;
                }
                
                Terminal.success('Client ID loaded', clientId.substring(0, 10) + '...');
                Terminal.info('Client Secret', clientSecret ? 'CONFIGURED' : 'MISSING');
                
                this.config.CLIENT_ID = clientId;
                this.config.CLIENT_SECRET = clientSecret || '';
                
                // Exchange code for token
                await this.exchangeCodeForToken(code);
            },
            
            async exchangeCodeForToken(code) {
                Terminal.info('üîÑ Starting OAuth token exchange...');
                Terminal.debug('Token URL', this.config.TOKEN_URL);
                Terminal.debug('Client ID', this.config.CLIENT_ID.substring(0, 15) + '...');
                Terminal.debug('Redirect URI', this.config.REDIRECT_URI);
                Terminal.debug('Code', code.substring(0, 20) + '...');
                
                const requestBody = {
                    client_id: this.config.CLIENT_ID,
                    client_secret: this.config.CLIENT_SECRET,
                    code: code,
                    redirect_uri: this.config.REDIRECT_URI
                };
                
                Terminal.debug('Request body prepared', {
                    client_id: requestBody.client_id.substring(0, 15) + '...',
                    client_secret: requestBody.client_secret ? 'SET' : 'EMPTY',
                    code: code.substring(0, 15) + '...',
                    redirect_uri: requestBody.redirect_uri
                });
                
                // Try Strategy 1: CustomCorsWidget
                Terminal.info('üì° Strategy 1: CustomCorsWidget CORS Bypass');
                Terminal.info('üí° Using Web Workers to bypass CORS restrictions');
                Terminal.info('üìù Workers run in separate context with different security model');
                
                if (!window.CustomCorsWidget) {
                    Terminal.error('CustomCorsWidget NOT LOADED - infrastructure failure');
                    Terminal.warning('Falling back to Strategy 2');
                } else {
                    Terminal.success('CustomCorsWidget class available');
                    
                    try {
                        // Check if initialized
                        if (!window.CustomCorsWidget.initialized) {
                            Terminal.warning('CustomCorsWidget not initialized, initializing now...');
                            const initStart = Date.now();
                            
                            await Promise.race([
                                window.CustomCorsWidget.init(),
                                new Promise((_, reject) => 
                                    setTimeout(() => reject(new Error('Initialization timeout after 15s')), 15000)
                                )
                            ]);
                            
                            const initTime = Date.now() - initStart;
                            Terminal.success(`CustomCorsWidget initialized in ${initTime}ms`);
                        } else {
                            Terminal.success('CustomCorsWidget already initialized');
                        }
                        
                        Terminal.info('üöÄ Attempting token exchange via CustomCorsWidget.fetch()...');
                        const fetchStart = Date.now();
                        
                        const response = await window.CustomCorsWidget.fetch(this.config.TOKEN_URL, {
                            method: 'POST',
                            headers: {
                                'Accept': 'application/json',
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify(requestBody)
                        });
                        
                        const fetchTime = Date.now() - fetchStart;
                        Terminal.info(`Fetch completed in ${fetchTime}ms`);
                        Terminal.debug('Response', {
                            status: response.status,
                            ok: response.ok,
                            statusText: response.statusText
                        });
                        
                        const responseText = await response.text();
                        Terminal.debug('Response body (raw)', responseText.substring(0, 200));
                        
                        // Check if response is empty (common CORS bypass failure)
                        if (!responseText || responseText.trim() === '') {
                            Terminal.error('‚ùå Response body is EMPTY');
                            Terminal.warning('‚ö†Ô∏è Worker may not have proper CORS bypass capability');
                            Terminal.info('üí° Trying fallback strategies...');
                            throw new Error('Empty response from CustomCorsWidget');
                        }
                        
                        let tokenData;
                        try {
                            tokenData = JSON.parse(responseText);
                            Terminal.success('‚úÖ Response parsed as JSON successfully');
                        } catch (e) {
                            Terminal.error('‚ùå Failed to parse response as JSON', e.message);
                            Terminal.error('Raw response', responseText);
                            Terminal.info('üí° Trying fallback strategies...');
                            throw new Error('Invalid JSON response');
                        }
                        
                        if (tokenData.access_token) {
                            Terminal.success('üéâ TOKEN EXCHANGE SUCCESSFUL via CustomCorsWidget!');
                            Terminal.debug('Token type', tokenData.token_type);
                            Terminal.debug('Access token', tokenData.access_token.substring(0, 20) + '...');
                            Terminal.debug('Scope', tokenData.scope);
                            
                            await this.handleSuccess(tokenData);
                            return;
                        } else if (tokenData.error) {
                            Terminal.error('GitHub returned error in response', tokenData);
                            this.showError(tokenData.error_description || tokenData.error);
                            return;
                        } else {
                            Terminal.error('Unexpected response format', tokenData);
                            this.showError('Unexpected response from GitHub');
                            return;
                        }
                        
                    } catch (error) {
                        Terminal.error('‚ùå CustomCorsWidget strategy FAILED', error.message);
                        Terminal.debug('Error stack', error.stack);
                        Terminal.warning('Trying fallback strategies...');
                    }
                }
                
                // Try Strategy 2: Public CORS Proxy - cors.proxy.com
                Terminal.info('üì° Strategy 2: Public CORS Proxy (corsproxy.io)');
                Terminal.info('üí° Attempting to use public CORS proxy infrastructure');
                
                try {
                    // Try corsproxy.io - a public CORS proxy
                    const proxyUrl = 'https://corsproxy.io/?';
                    const encodedUrl = encodeURIComponent(this.config.TOKEN_URL);
                    Terminal.debug('Proxy URL', proxyUrl + encodedUrl);
                    
                    const proxiedResponse = await fetch(proxyUrl + encodedUrl, {
                        method: 'POST',
                        headers: {
                            'Accept': 'application/json',
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(requestBody)
                    });
                    
                    Terminal.debug('Proxy response', {
                        status: proxiedResponse.status,
                        ok: proxiedResponse.ok
                    });
                    
                    if (proxiedResponse.ok) {
                        const tokenData = await proxiedResponse.json();
                        
                        if (tokenData.access_token) {
                            Terminal.success('üéâ TOKEN EXCHANGE SUCCESSFUL via corsproxy.io!');
                            Terminal.info('üí° Using public proxy - works but not recommended for production');
                            await this.handleSuccess(tokenData);
                            return;
                        } else if (tokenData.error) {
                            Terminal.error('GitHub returned error', tokenData);
                            this.showError(tokenData.error_description || tokenData.error);
                            return;
                        }
                    }
                } catch (error) {
                    Terminal.error('‚ùå corsproxy.io strategy FAILED', error.message);
                    Terminal.info('Trying alternative proxies...');
                }
                
                // Try Strategy 3: Alternative proxy - allorigins.win
                Terminal.info('üì° Strategy 3: Alternative CORS Proxy (allorigins.win)');
                
                try {
                    const proxyUrl = 'https://api.allorigins.win/raw?url=';
                    const encodedUrl = encodeURIComponent(this.config.TOKEN_URL);
                    Terminal.debug('Trying AllOrigins proxy', proxyUrl + encodedUrl);
                    
                    const proxiedResponse = await fetch(proxyUrl + encodedUrl, {
                        method: 'POST',
                        headers: {
                            'Accept': 'application/json',
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(requestBody)
                    });
                    
                    if (proxiedResponse.ok) {
                        const tokenData = await proxiedResponse.json();
                        
                        if (tokenData.access_token) {
                            Terminal.success('üéâ TOKEN EXCHANGE SUCCESSFUL via allorigins.win!');
                            await this.handleSuccess(tokenData);
                            return;
                        }
                    }
                } catch (error) {
                    Terminal.error('‚ùå allorigins.win strategy FAILED', error.message);
                }
                
                // Try Strategy 4: cors-anywhere
                Terminal.info('üì° Strategy 4: CORS Anywhere Proxy');
                
                try {
                    const proxyUrl = 'https://cors-anywhere.herokuapp.com/';
                    Terminal.debug('Proxy URL', proxyUrl);
                    
                    const proxiedResponse = await fetch(proxyUrl + this.config.TOKEN_URL, {
                        method: 'POST',
                        headers: {
                            'Accept': 'application/json',
                            'Content-Type': 'application/json',
                            'X-Requested-With': 'XMLHttpRequest'
                        },
                        body: JSON.stringify(requestBody)
                    });
                    
                    if (proxiedResponse.ok) {
                        const tokenData = await proxiedResponse.json();
                        
                        if (tokenData.access_token) {
                            Terminal.success('üéâ TOKEN EXCHANGE SUCCESSFUL via cors-anywhere!');
                            await this.handleSuccess(tokenData);
                            return;
                        }
                    }
                } catch (error) {
                    Terminal.error('‚ùå cors-anywhere strategy FAILED', error.message);
                }
                
                // Try Strategy 5: Direct Fetch (last resort - will likely fail)
                Terminal.info('üì° Strategy 5: Direct Fetch');
                
                try {
                    const response = await fetch(this.config.TOKEN_URL, {
                        method: 'POST',
                        headers: {
                            'Accept': 'application/json',
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(requestBody)
                    });
                    
                    const tokenData = await response.json();
                    
                    if (tokenData.access_token) {
                        Terminal.success('üéâ TOKEN EXCHANGE SUCCESSFUL via Direct Fetch!');
                        await this.handleSuccess(tokenData);
                        return;
                    }
                } catch (error) {
                    Terminal.error('‚ùå Direct fetch FAILED', error.message);
                }
                
                // All strategies failed
                Terminal.error('üö´ ALL STRATEGIES FAILED');
                Terminal.error('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
                Terminal.error('üí° Attempted:');
                Terminal.error('   1. Web Worker direct fetch');
                Terminal.error('   2. corsproxy.io');
                Terminal.error('   3. allorigins.win');
                Terminal.error('   4. cors-anywhere');
                Terminal.error('   5. Direct fetch');
                Terminal.error('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
                Terminal.error('üìã All public CORS proxies failed or are unavailable');
                Terminal.info('üí° Alternative: Use GitHub Device Flow (no CORS issues)');
                Terminal.info('   Visit: https://github.com/login/device');
                Terminal.error('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
                this.showError('Token exchange failed. All CORS proxy strategies exhausted. Try GitHub Device Flow.');
            },
            
            async handleSuccess(tokenData) {
                Terminal.success('üíæ Storing access token...');
                
                try {
                    // Store token
                    localStorage.setItem('copilot_access_token', tokenData.access_token);
                    localStorage.setItem('copilot_token_type', tokenData.token_type || 'bearer');
                    localStorage.setItem('copilot_scope', tokenData.scope || '');
                    
                    Terminal.success('Token stored in localStorage');
                    Terminal.info('Token type', tokenData.token_type);
                    Terminal.info('Scope', tokenData.scope);
                    
                    // Show success state
                    this.showState('success');
                    
                    // Start countdown
                    let countdown = 5;
                    const countdownEl = document.getElementById('countdown');
                    const interval = setInterval(() => {
                        countdown--;
                        if (countdownEl) {
                            countdownEl.textContent = countdown;
                        }
                        
                        if (countdown <= 0) {
                            clearInterval(interval);
                            Terminal.info('üîÑ Redirecting to app...');
                            window.location.href = '../../index.html';
                        }
                    }, 1000);
                    
                } catch (error) {
                    Terminal.error('Failed to store token', error.message);
                    this.showError('Failed to store access token: ' + error.message);
                }
            },
            
            showState(state) {
                Terminal.info(`Switching to state: ${state}`);
                document.getElementById('state-processing').classList.add('hidden');
                document.getElementById('state-success').classList.add('hidden');
                document.getElementById('state-error').classList.add('hidden');
                document.getElementById('state-no-code').classList.add('hidden');
                
                document.getElementById('state-' + state).classList.remove('hidden');
            },
            
            showError(message) {
                Terminal.error('Showing error to user', message);
                document.getElementById('error-message').textContent = message;
                this.showState('error');
            }
        };

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            Terminal.info('üé¨ Page loaded - starting OAuth callback handler');
            OAuthHandler.init();
        });
    </script>
</body>
</html>
