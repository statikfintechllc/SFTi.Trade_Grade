<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#000000">
    <title>SFTi P.R.E.P - OAuth Callback</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            background: linear-gradient(135deg, #1a1a1a 0%, #0a0a0a 100%);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            color: #e0e0e0;
        }

        .container {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .card {
            background: rgba(30, 30, 30, 0.95);
            border: 1px solid rgba(204, 0, 0, 0.3);
            border-radius: 16px 16px 0 0;
            padding: 40px;
            max-width: 600px;
            width: 100%;
            text-align: center;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        .logo-container {
            margin-bottom: 24px;
        }

        .logo {
            width: 64px;
            height: 64px;
        }

        h1 {
            font-size: 24px;
            margin-bottom: 8px;
            color: #ffffff;
        }

        .status {
            font-size: 16px;
            margin-bottom: 24px;
            color: #888;
        }

        .status.success {
            color: #00cc66;
        }

        .status.error {
            color: #cc0000;
        }

        .status.processing {
            color: #00bcd4;
        }

        .spinner {
            width: 48px;
            height: 48px;
            border: 3px solid rgba(204, 0, 0, 0.2);
            border-top-color: #cc0000;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 24px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .icon {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
        }

        .icon.success {
            color: #00cc66;
        }

        .icon.error {
            color: #cc0000;
        }

        .message {
            font-size: 14px;
            color: #888;
            line-height: 1.6;
            margin-bottom: 24px;
        }

        .debug-info {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin-top: 16px;
            font-family: monospace;
            font-size: 11px;
            color: #666;
            text-align: left;
            word-break: break-all;
            max-height: 150px;
            overflow-y: auto;
        }

        /* Verbose Debug Terminal */
        .debug-terminal {
            background: rgba(10, 10, 10, 0.98);
            border: 1px solid rgba(204, 0, 0, 0.3);
            border-top: 2px solid #cc0000;
            border-radius: 0 0 16px 16px;
            max-width: 600px;
            width: 100%;
            height: 400px;
            display: flex;
            flex-direction: column;
            font-family: 'Courier New', 'Consolas', monospace;
            font-size: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            margin-top: 0;
        }

        .debug-header {
            background: rgba(204, 0, 0, 0.1);
            padding: 12px 16px;
            border-bottom: 1px solid rgba(204, 0, 0, 0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        .debug-title {
            color: #cc0000;
            font-weight: bold;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .debug-title::before {
            content: "âš¡";
            font-size: 16px;
        }

        .debug-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 12px;
            background: rgba(0, 0, 0, 0.5);
        }

        .debug-line {
            margin: 2px 0;
            padding: 4px;
            border-left: 2px solid transparent;
        }

        .debug-line.info {
            color: #00bcd4;
            border-left-color: #00bcd4;
        }

        .debug-line.success {
            color: #00cc66;
            border-left-color: #00cc66;
        }

        .debug-line.error {
            color: #cc0000;
            border-left-color: #cc0000;
        }

        .debug-line.warning {
            color: #ff9800;
            border-left-color: #ff9800;
        }

        .debug-line.debug {
            color: #666;
            border-left-color: #333;
        }

        .debug-timestamp {
            color: #444;
            font-size: 9px;
            margin-right: 8px;
        }

        .btn {
            display: inline-block;
            background: linear-gradient(135deg, #cc0000 0%, #990000 100%);
            color: white;
            border: none;
            padding: 12px 32px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            text-decoration: none;
            transition: all 0.2s;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(204, 0, 0, 0.4);
        }

        .countdown {
            font-size: 12px;
            color: #666;
            margin-top: 16px;
        }

        /* Hidden states */
        .hidden {
            display: none !important;
        }
    </style>
    <!-- Load CORS bypass widget for OAuth proxy -->
    <script src="../../js.on/cors-bypass.js"></script>
</head>
<body>
    <div class="container">
        <div class="card">
            <!-- Logo -->
            <div class="logo-container">
                <svg class="logo" viewBox="0 0 285 285" xmlns="http://www.w3.org/2000/svg">
                    <rect x="0" y="0" width="285" height="285" rx="64" fill="#C0392B"/>
                    <path d="M30 84 L60 94 L90 89 L120 79 L150 99 L180 94 L210 89 L240 84 L255 86" stroke="#FFA500" stroke-width="3" stroke-dasharray="6 4" fill="none" opacity="0.8"/>
                    <rect x="33" y="104" width="12" height="36" fill="white"/>
                    <line x1="39" y1="94" x2="39" y2="104" stroke="white" stroke-width="2.5"/>
                    <line x1="39" y1="140" x2="39" y2="150" stroke="white" stroke-width="2.5"/>
                    <rect x="58" y="114" width="12" height="28" fill="#212121"/>
                    <line x1="64" y1="102" x2="64" y2="114" stroke="#212121" stroke-width="2.5"/>
                    <line x1="64" y1="142" x2="64" y2="154" stroke="#212121" stroke-width="2.5"/>
                    <rect x="83" y="99" width="12" height="42" fill="white"/>
                    <line x1="89" y1="88" x2="89" y2="99" stroke="white" stroke-width="2.5"/>
                    <line x1="89" y1="141" x2="89" y2="152" stroke="white" stroke-width="2.5"/>
                    <rect x="108" y="74" width="12" height="52" fill="white"/>
                    <line x1="114" y1="62" x2="114" y2="74" stroke="white" stroke-width="2.5"/>
                    <line x1="114" y1="126" x2="114" y2="138" stroke="white" stroke-width="2.5"/>
                    <rect x="133" y="94" width="12" height="38" fill="#212121"/>
                    <line x1="139" y1="82" x2="139" y2="94" stroke="#212121" stroke-width="2.5"/>
                    <line x1="139" y1="132" x2="139" y2="144" stroke="#212121" stroke-width="2.5"/>
                    <rect x="158" y="109" width="12" height="30" fill="#212121"/>
                    <line x1="164" y1="97" x2="164" y2="109" stroke="#212121" stroke-width="2.5"/>
                    <line x1="164" y1="139" x2="164" y2="151" stroke="#212121" stroke-width="2.5"/>
                    <rect x="183" y="102" width="12" height="34" fill="white"/>
                    <line x1="189" y1="90" x2="189" y2="102" stroke="white" stroke-width="2.5"/>
                    <line x1="189" y1="136" x2="189" y2="148" stroke="white" stroke-width="2.5"/>
                    <rect x="208" y="80" width="12" height="48" fill="white"/>
                    <line x1="214" y1="68" x2="214" y2="80" stroke="white" stroke-width="2.5"/>
                    <line x1="214" y1="128" x2="214" y2="148" stroke="white" stroke-width="2.5"/>
                    <rect x="233" y="60" width="12" height="44" fill="white"/>
                    <line x1="239" y1="46" x2="239" y2="60" stroke="white" stroke-width="2.5"/>
                    <line x1="239" y1="104" x2="239" y2="110" stroke="white" stroke-width="2.5"/>
                    <path d="M15 174H270" stroke="white" stroke-width="4" stroke-linecap="round"/>
                    <path d="M39 174V190L24 205" stroke="white" stroke-width="2.5" stroke-linecap="round" fill="none"/>
                    <circle cx="24" cy="205" r="4" fill="white"/>
                    <path d="M64 174V198L49 213" stroke="white" stroke-width="2.5" stroke-linecap="round" fill="none"/>
                    <circle cx="49" cy="213" r="4" fill="white"/>
                    <path d="M89 174V205" stroke="white" stroke-width="2.5" stroke-linecap="round" fill="none"/>
                    <circle cx="89" cy="205" r="4" fill="white"/>
                    <path d="M114 174V198L129 213" stroke="white" stroke-width="2.5" stroke-linecap="round" fill="none"/>
                    <circle cx="129" cy="213" r="4" fill="white"/>
                    <path d="M139 174V190L154 205" stroke="white" stroke-width="2.5" stroke-linecap="round" fill="none"/>
                    <circle cx="154" cy="205" r="4" fill="white"/>
                    <path d="M164 174V205" stroke="white" stroke-width="2.5" stroke-linecap="round" fill="none"/>
                    <circle cx="164" cy="205" r="4" fill="white"/>
                    <path d="M189 174V190L204 205" stroke="white" stroke-width="2.5" stroke-linecap="round" fill="none"/>
                    <circle cx="204" cy="205" r="4" fill="white"/>
                    <path d="M214 174V198L229 213" stroke="white" stroke-width="2.5" stroke-linecap="round" fill="none"/>
                    <circle cx="229" cy="213" r="4" fill="white"/>
                    <path d="M239 174V190L254 205" stroke="white" stroke-width="2.5" stroke-linecap="round" fill="none"/>
                    <circle cx="254" cy="205" r="4" fill="white"/>
                </svg>
            </div>

            <h1>SFTi P.R.E.P</h1>

            <!-- Processing State -->
            <div id="state-processing">
                <div class="spinner"></div>
                <p class="status processing">Processing OAuth...</p>
                <p class="message">Please wait while we complete authentication.</p>
            </div>

            <!-- Success State -->
            <div id="state-success" class="hidden">
                <svg class="icon success" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"/>
                    <path d="M9 12l2 2 4-4"/>
                </svg>
                <p class="status success">Authentication Successful!</p>
                <p class="message">Your GitHub Copilot access has been configured. You can now use all available AI models.</p>
                <a href="../../index.html" class="btn">Return to App</a>
                <p class="countdown">Redirecting in <span id="countdown">5</span> seconds...</p>
            </div>

            <!-- Error State -->
            <div id="state-error" class="hidden">
                <svg class="icon error" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"/>
                    <path d="M15 9l-6 6M9 9l6 6"/>
                </svg>
                <p class="status error">Authentication Failed</p>
                <p class="message" id="error-message">An error occurred during authentication.</p>
                <a href="../../index.html" class="btn">Return to App</a>
                <div class="debug-info" id="debug-info"></div>
            </div>

            <!-- Verbose Debug Terminal -->
            <div class="debug-terminal" id="debug-terminal">
                <div class="debug-header" onclick="toggleDebugTerminal()">
                    <span class="debug-title">ðŸ”§ DEBUG TERMINAL - OAuth Flow Monitor</span>
                    <span class="debug-toggle" id="debug-toggle">â–¼ Click to collapse</span>
                </div>
                <div id="debug-output"></div>
            </div>

            <!-- No Code State -->
            <div id="state-no-code" class="hidden">
                <svg class="icon" style="color: #888;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"/>
                    <path d="M12 8v4M12 16h.01"/>
                </svg>
                <p class="status">No Authorization Code</p>
                <p class="message">No OAuth authorization code was found. Please start the authentication process from the app.</p>
                <a href="../../index.html" class="btn">Go to App</a>
            </div>
        </div>
    </div>

    <script>
        /**
         * Verbose Debug Terminal System
         * Provides real-time visibility into OAuth flow execution
         */
        const DebugTerminal = {
            collapsed: false,
            maxLines: 500,
            
            init() {
                console.log('[DebugTerminal] Initializing verbose logging system...');
                this.log('info', 'Debug Terminal initialized - monitoring OAuth flow');
                this.log('info', `Timestamp: ${new Date().toISOString()}`);
                this.log('info', `URL: ${window.location.href}`);
                this.log('info', `User Agent: ${navigator.userAgent}`);
                
                // Intercept console methods
                this.interceptConsole();
            },
            
            log(level, message, data = null) {
                const timestamp = new Date().toLocaleTimeString('en-US', { 
                    hour12: false, 
                    hour: '2-digit', 
                    minute: '2-digit', 
                    second: '2-digit',
                    fractionalSecondDigits: 3
                });
                
                const output = document.getElementById('debug-output');
                if (!output) return;
                
                const line = document.createElement('div');
                line.className = `debug-line ${level}`;
                
                let content = `<span class="debug-timestamp">[${timestamp}]</span> ${message}`;
                if (data) {
                    content += `\n  ${JSON.stringify(data, null, 2)}`;
                }
                line.innerHTML = content;
                
                output.appendChild(line);
                
                // Auto-scroll to bottom
                const terminal = document.getElementById('debug-terminal');
                if (terminal && !this.collapsed) {
                    terminal.scrollTop = terminal.scrollHeight;
                }
                
                // Limit lines
                while (output.children.length > this.maxLines) {
                    output.removeChild(output.firstChild);
                }
                
                // Also log to console with prefix
                const prefix = `[OAuth Debug ${level.toUpperCase()}]`;
                if (level === 'error') {
                    console.error(prefix, message, data || '');
                } else if (level === 'warning') {
                    console.warn(prefix, message, data || '');
                } else {
                    console.log(prefix, message, data || '');
                }
            },
            
            interceptConsole() {
                const original = {
                    log: console.log,
                    warn: console.warn,
                    error: console.error
                };
                
                console.log = (...args) => {
                    original.log.apply(console, args);
                    const msg = args.map(a => typeof a === 'object' ? JSON.stringify(a) : a).join(' ');
                    if (msg.includes('[Callback]') || msg.includes('[CustomCorsWidget]')) {
                        this.log('debug', msg);
                    }
                };
                
                console.warn = (...args) => {
                    original.warn.apply(console, args);
                    const msg = args.map(a => typeof a === 'object' ? JSON.stringify(a) : a).join(' ');
                    this.log('warning', msg);
                };
                
                console.error = (...args) => {
                    original.error.apply(console, args);
                    const msg = args.map(a => typeof a === 'object' ? JSON.stringify(a) : a).join(' ');
                    this.log('error', msg);
                };
            }
        };
        
        // Toggle terminal collapse
        function toggleDebugTerminal() {
            const terminal = document.getElementById('debug-terminal');
            const toggle = document.getElementById('debug-toggle');
            DebugTerminal.collapsed = !DebugTerminal.collapsed;
            
            if (DebugTerminal.collapsed) {
                terminal.classList.add('collapsed');
                toggle.textContent = 'â–² Click to expand';
            } else {
                terminal.classList.remove('collapsed');
                toggle.textContent = 'â–¼ Click to collapse';
                terminal.scrollTop = terminal.scrollHeight;
            }
        }
        
        // Initialize debug terminal immediately
        DebugTerminal.init();
        
        /**
         * SFTi P.R.E.P - Static OAuth Callback Handler
         * 
         * This file handles the OAuth callback for GitHub authentication.
         * It's designed to work entirely client-side on GitHub Pages.
         * 
         * IMPORTANT: OAuth Web Flow has CORS limitations on GitHub Pages.
         * We STRONGLY RECOMMEND using Device Flow instead (no callback needed).
         * 
         * The flow:
         * 1. User clicks "Connect with GitHub" in the main app
         * 2. User is redirected to GitHub's OAuth authorization page
         * 3. After authorization, GitHub redirects back here with a code
         * 4. We attempt to exchange code for token (may fail due to CORS)
         * 5. Token is stored and user is redirected back to the app
         * 
         * NOTE: This callback is primarily for compatibility.
         * For better experience, use Device Flow which doesn't require this page.
         */

        // Note: CORS limitations mean token exchange often fails here
        // Device Flow is the recommended authentication method

        const OAuthCallbackHandler = {
            // Configuration
            config: {
                // Storage keys
                STORAGE_KEYS: {
                    PENDING_STATE: 'oauth_pending_state',
                    COPILOT_TOKEN: 'copilotToken',
                    COPILOT_EXPIRY: 'copilotTokenExpiry',
                    GITHUB_TOKEN: 'githubToken',
                    OAUTH_STATE: 'oauth_state',
                    DEVICE_CODE: 'device_code_data'
                },
                
                // GitHub OAuth endpoints
                TOKEN_URL: 'https://github.com/login/oauth/access_token',
                
                // Redirect delay after success
                REDIRECT_DELAY: 5000,
                
                // Main app URL
                APP_URL: '../../index.html'
            },

            // State management
            setState(state) {
                document.getElementById('state-processing').classList.add('hidden');
                document.getElementById('state-success').classList.add('hidden');
                document.getElementById('state-error').classList.add('hidden');
                document.getElementById('state-no-code').classList.add('hidden');
                document.getElementById(`state-${state}`).classList.remove('hidden');
            },

            // Show success state with countdown
            showSuccess(token, tokenType = 'copilot') {
                this.setState('success');
                
                // Store token
                if (tokenType === 'copilot') {
                    localStorage.setItem(this.config.STORAGE_KEYS.COPILOT_TOKEN, token);
                    // Set expiry to 8 hours from now (GitHub Copilot tokens)
                    const expiry = Date.now() + (8 * 60 * 60 * 1000);
                    localStorage.setItem(this.config.STORAGE_KEYS.COPILOT_EXPIRY, expiry.toString());
                } else {
                    localStorage.setItem(this.config.STORAGE_KEYS.GITHUB_TOKEN, token);
                }
                
                // Broadcast to other tabs via BroadcastChannel
                if ('BroadcastChannel' in window) {
                    const channel = new BroadcastChannel('sfti-backend');
                    channel.postMessage({
                        type: 'TOKEN_UPDATE',
                        tokenType: tokenType,
                        token: token
                    });
                    channel.close();
                }
                
                // Notify opener window if exists (popup flow)
                if (window.opener && !window.opener.closed) {
                    window.opener.postMessage({
                        type: 'OAUTH_SUCCESS',
                        token: token,
                        tokenType: tokenType
                    }, '*');
                }
                
                // Clear pending OAuth state
                localStorage.removeItem(this.config.STORAGE_KEYS.PENDING_STATE);
                localStorage.removeItem(this.config.STORAGE_KEYS.OAUTH_STATE);
                localStorage.removeItem(this.config.STORAGE_KEYS.DEVICE_CODE);
                
                // Start countdown and redirect
                this.startCountdown();
            },

            // Show error state
            showError(message, debugData = null) {
                this.setState('error');
                document.getElementById('error-message').textContent = message;
                
                if (debugData) {
                    const debugEl = document.getElementById('debug-info');
                    debugEl.textContent = typeof debugData === 'string' 
                        ? debugData 
                        : JSON.stringify(debugData, null, 2);
                    debugEl.classList.remove('hidden');
                }
                
                // Notify opener window if exists
                if (window.opener && !window.opener.closed) {
                    window.opener.postMessage({
                        type: 'OAUTH_ERROR',
                        error: message
                    }, '*');
                }
            },

            // Countdown timer for redirect
            startCountdown() {
                let seconds = 5;
                const countdownEl = document.getElementById('countdown');
                
                const timer = setInterval(() => {
                    seconds--;
                    countdownEl.textContent = seconds;
                    
                    if (seconds <= 0) {
                        clearInterval(timer);
                        this.redirect();
                    }
                }, 1000);
            },

            // Redirect to main app
            redirect() {
                // Close popup if in popup mode
                if (window.opener && !window.opener.closed) {
                    window.close();
                } else {
                    window.location.href = this.config.APP_URL;
                }
            },

            // Parse URL parameters
            getURLParams() {
                const params = new URLSearchParams(window.location.search);
                const hashParams = new URLSearchParams(window.location.hash.substring(1));
                
                return {
                    code: params.get('code') || hashParams.get('code'),
                    state: params.get('state') || hashParams.get('state'),
                    error: params.get('error') || hashParams.get('error'),
                    error_description: params.get('error_description') || hashParams.get('error_description'),
                    access_token: hashParams.get('access_token'),
                    token_type: hashParams.get('token_type')
                };
            },

            // Validate state parameter (CSRF protection)
            validateState(receivedState) {
                const storedState = localStorage.getItem(this.config.STORAGE_KEYS.OAUTH_STATE);
                
                if (!storedState) {
                    console.warn('No stored state found');
                    return true; // Allow if no state stored (first time use)
                }
                
                return receivedState === storedState;
            },

            // Exchange authorization code for token
            // Uses our self-hosted CORS bypass proxy system
            async exchangeCodeForToken(code) {
                DebugTerminal.log('info', 'ðŸ”„ Starting OAuth token exchange process');
                DebugTerminal.log('debug', `Authorization code: ${code.substring(0, 10)}...`);
                
                // Get stored OAuth app credentials
                const clientId = localStorage.getItem('oauth_client_id');
                const clientSecret = localStorage.getItem('oauth_client_secret');
                
                DebugTerminal.log('debug', `Client ID: ${clientId ? clientId.substring(0, 10) + '...' : 'NOT SET'}`);
                DebugTerminal.log('debug', `Client Secret: ${clientSecret ? 'SET' : 'NOT SET'}`);
                
                if (!clientId) {
                    DebugTerminal.log('error', 'âŒ OAuth Client ID not configured');
                    throw new Error('OAuth Client ID not configured. Please set up your GitHub OAuth App credentials in the main application.');
                }
                
                if (!clientSecret) {
                    DebugTerminal.log('error', 'âŒ OAuth Client Secret not configured');
                    throw new Error('OAuth Client Secret not configured. GitHub OAuth Web Flow requires both Client ID and Client Secret.');
                }
                
                const redirectUri = window.location.origin + window.location.pathname;
                DebugTerminal.log('debug', `Redirect URI: ${redirectUri}`);
                
                const tokenExchangeParams = new URLSearchParams({
                    client_id: clientId,
                    client_secret: clientSecret,
                    code: code,
                    redirect_uri: redirectUri
                });
                
                DebugTerminal.log('debug', `Token exchange URL: ${this.config.TOKEN_URL}`);
                DebugTerminal.log('debug', `Request body (params): ${tokenExchangeParams.toString().replace(clientSecret, '***')}`);
                
                // Infrastructure is already loaded (synchronously in head)
                // If CustomCorsWidget doesn't exist, the page is broken - fail immediately
                
                // Strategy 1: Try using CustomCorsWidget (loaded synchronously, must be available)
                try {
                    DebugTerminal.log('info', 'ðŸ“¡ Strategy 1: CustomCorsWidget CORS Bypass');
                    
                    if (!window.CustomCorsWidget) {
                        DebugTerminal.log('error', 'âŒ FATAL: CustomCorsWidget not loaded');
                        throw new Error('FATAL: CustomCorsWidget not loaded. Infrastructure scripts failed to load.');
                    }
                    
                    DebugTerminal.log('success', 'âœ… CustomCorsWidget class available');
                    
                    // Initialize if not yet initialized - WITH TIMEOUT
                    if (!window.CustomCorsWidget.initialized) {
                        DebugTerminal.log('warning', 'âš ï¸  CustomCorsWidget not initialized, initializing now (15s timeout)...');
                        
                        const initStartTime = Date.now();
                        
                        // Race initialization against 15-second timeout
                        try {
                            await Promise.race([
                                window.CustomCorsWidget.init(),
                                new Promise((_, reject) => 
                                    setTimeout(() => reject(new Error('Initialization timeout')), 15000)
                                )
                            ]);
                            
                            const initDuration = Date.now() - initStartTime;
                            DebugTerminal.log('success', `âœ… CustomCorsWidget initialized in ${initDuration}ms`);
                        } catch (initError) {
                            DebugTerminal.log('error', `âŒ Initialization failed: ${initError.message}`);
                            throw initError;
                        }
                    } else {
                        DebugTerminal.log('success', 'âœ… CustomCorsWidget already initialized');
                    }
                    
                    DebugTerminal.log('info', 'ðŸš€ Attempting token exchange via CustomCorsWidget.fetch()');
                    const fetchStartTime = Date.now();
                    
                    const response = await window.CustomCorsWidget.fetch(this.config.TOKEN_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                            'Accept': 'application/json'
                        },
                        body: tokenExchangeParams.toString()
                    });
                    
                    const fetchDuration = Date.now() - fetchStartTime;
                    DebugTerminal.log('debug', `Fetch completed in ${fetchDuration}ms`);
                    DebugTerminal.log('debug', `Response: ${response ? `status ${response.status}, ok=${response.ok}` : 'null'}`);
                    
                    if (response && response.ok) {
                        const tokenData = await response.json();
                        DebugTerminal.log('success', 'ðŸŽ‰ TOKEN EXCHANGE SUCCESSFUL via CustomCorsWidget!');
                        DebugTerminal.log('debug', `Token type: ${tokenData.token_type || 'unknown'}`);
                        DebugTerminal.log('debug', `Access token: ${tokenData.access_token ? tokenData.access_token.substring(0, 20) + '...' : 'missing'}`);
                        return tokenData;
                    } else {
                        const errorMsg = `Response not OK: ${response ? response.status : 'null response'}`;
                        DebugTerminal.log('warning', `âš ï¸  ${errorMsg}`);
                        if (response && !response.ok) {
                            try {
                                const errorText = await response.text();
                                DebugTerminal.log('debug', `Response body: ${errorText.substring(0, 200)}`);
                            } catch (e) {
                                DebugTerminal.log('debug', 'Could not read response body');
                            }
                        }
                    }
                } catch (error) {
                    DebugTerminal.log('error', `âŒ Strategy 1 FAILED: ${error.message}`);
                    DebugTerminal.log('debug', `Error stack: ${error.stack}`);
                    // Continue to next strategy
                }
                
                // Strategy 2: Try JSONP approach for GET fallback
                try {
                    DebugTerminal.log('info', 'ðŸ“¡ Strategy 2: JSONP Fallback');
                    const jsonpUrl = `${this.config.TOKEN_URL}?${tokenExchangeParams.toString()}`;
                    DebugTerminal.log('debug', `JSONP URL: ${jsonpUrl.replace(clientSecret, '***')}`);
                    
                    const tokenData = await this.jsonpFetch(jsonpUrl);
                    if (tokenData && tokenData.access_token) {
                        DebugTerminal.log('success', 'ðŸŽ‰ TOKEN EXCHANGE SUCCESSFUL via JSONP!');
                        return tokenData;
                    }
                    DebugTerminal.log('warning', 'âš ï¸  JSONP returned no token');
                } catch (error) {
                    DebugTerminal.log('error', `âŒ Strategy 2 FAILED: ${error.message}`);
                    // Continue to next strategy
                }
                
                // Strategy 3: Try using Service Worker proxy
                try {
                    DebugTerminal.log('info', 'ðŸ“¡ Strategy 3: Service Worker Proxy');
                    
                    if ('serviceWorker' in navigator) {
                        DebugTerminal.log('debug', 'Service Worker API available');
                        if (navigator.serviceWorker.controller) {
                            DebugTerminal.log('success', 'âœ… Service Worker controlling page');
                            
                            const response = await fetch(this.config.TOKEN_URL, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/x-www-form-urlencoded',
                                    'Accept': 'application/json',
                                    'X-Cors-Proxy': 'true' // Marker for service worker
                                },
                                body: tokenExchangeParams.toString()
                            });
                            
                            DebugTerminal.log('debug', `SW Response: status ${response.status}, ok=${response.ok}`);
                            
                            if (response.ok) {
                                const tokenData = await response.json();
                                DebugTerminal.log('success', 'ðŸŽ‰ TOKEN EXCHANGE SUCCESSFUL via Service Worker!');
                                return tokenData;
                            }
                        } else {
                            DebugTerminal.log('warning', 'âš ï¸  Service Worker not controlling page');
                        }
                    } else {
                        DebugTerminal.log('warning', 'âš ï¸  Service Worker API not available');
                    }
                } catch (error) {
                    DebugTerminal.log('error', `âŒ Strategy 3 FAILED: ${error.message}`);
                    // Continue to next strategy
                }
                
                // Strategy 4: Try iframe proxy
                try {
                    DebugTerminal.log('info', 'ðŸ“¡ Strategy 4: Iframe Proxy');
                    
                    const tokenData = await this.iframeProxyFetch(this.config.TOKEN_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                            'Accept': 'application/json'
                        },
                        body: tokenExchangeParams.toString()
                    });
                    
                    if (tokenData && tokenData.access_token) {
                        DebugTerminal.log('success', 'ðŸŽ‰ TOKEN EXCHANGE SUCCESSFUL via iframe proxy!');
                        return tokenData;
                    }
                    DebugTerminal.log('warning', 'âš ï¸  Iframe proxy returned no token');
                } catch (error) {
                    DebugTerminal.log('error', `âŒ Strategy 4 FAILED: ${error.message}`);
                }
                
                // All strategies failed
                DebugTerminal.log('error', 'ðŸ’¥ ALL STRATEGIES FAILED - Token exchange impossible');
                DebugTerminal.log('info', 'ðŸ’¡ Recommendation: Use Device Flow authentication instead');
                
                throw new Error(
                    `All OAuth proxy strategies failed. ` +
                    `For better reliability, please use Device Flow authentication ` +
                    `which doesn't require a callback URL or token exchange.`
                );
            },
            
            // JSONP fetch helper
            jsonpFetch(url, timeout = 10000) {
                return new Promise((resolve, reject) => {
                    const callbackName = 'jsonp_callback_' + Math.random().toString(36).substring(7);
                    const script = document.createElement('script');
                    const timer = setTimeout(() => {
                        cleanup();
                        reject(new Error('JSONP request timeout'));
                    }, timeout);
                    
                    const cleanup = () => {
                        clearTimeout(timer);
                        if (script.parentNode) {
                            script.parentNode.removeChild(script);
                        }
                        delete window[callbackName];
                    };
                    
                    window[callbackName] = (data) => {
                        cleanup();
                        resolve(data);
                    };
                    
                    script.onerror = () => {
                        cleanup();
                        reject(new Error('JSONP script load error'));
                    };
                    
                    script.src = url + (url.includes('?') ? '&' : '?') + 'callback=' + callbackName;
                    document.head.appendChild(script);
                });
            },
            
            // Iframe proxy helper
            iframeProxyFetch(url, options) {
                return new Promise((resolve, reject) => {
                    const iframe = document.createElement('iframe');
                    iframe.style.display = 'none';
                    iframe.sandbox = 'allow-scripts allow-same-origin'; // Need same-origin for postMessage
                    
                    const timer = setTimeout(() => {
                        cleanup();
                        reject(new Error('Iframe proxy timeout'));
                    }, 15000);
                    
                    const cleanup = () => {
                        clearTimeout(timer);
                        window.removeEventListener('message', messageHandler);
                        if (iframe.parentNode) {
                            iframe.parentNode.removeChild(iframe);
                        }
                    };
                    
                    const messageHandler = (event) => {
                        if (event.source !== iframe.contentWindow) return;
                        
                        if (event.data.type === 'FETCH_SUCCESS') {
                            cleanup();
                            resolve(event.data.data);
                        } else if (event.data.type === 'FETCH_ERROR') {
                            cleanup();
                            reject(new Error(event.data.error));
                        }
                    };
                    
                    window.addEventListener('message', messageHandler);
                    
                    // Create iframe content that performs the fetch
                    const iframeHtml = `
                        <!DOCTYPE html>
                        <html>
                        <head><meta charset="utf-8"></head>
                        <body>
                        <script>
                            (async function() {
                                try {
                                    const response = await fetch('${url}', ${JSON.stringify(options)});
                                    const data = await response.json();
                                    parent.postMessage({ type: 'FETCH_SUCCESS', data: data }, '*');
                                } catch (error) {
                                    parent.postMessage({ type: 'FETCH_ERROR', error: error.message }, '*');
                                }
                            })();
                        </script>
                        </body>
                        </html>
                    `;
                    
                    iframe.srcdoc = iframeHtml;
                    document.body.appendChild(iframe);
                });
            },

            // Handle implicit grant flow (token in URL hash)
            handleImplicitGrant(accessToken, tokenType) {
                console.log('Handling implicit grant token');
                this.showSuccess(accessToken, 'copilot');
            },

            // Handle authorization code flow
            async handleCodeFlow(code, state) {
                DebugTerminal.log('info', 'ðŸ” Starting authorization code flow');
                DebugTerminal.log('debug', `Code: ${code.substring(0, 15)}...`);
                DebugTerminal.log('debug', `State: ${state || 'not provided'}`);
                
                // Validate state
                if (state && !this.validateState(state)) {
                    DebugTerminal.log('error', 'âŒ State validation failed - possible CSRF attack');
                    const expected = localStorage.getItem(this.config.STORAGE_KEYS.OAUTH_STATE);
                    DebugTerminal.log('debug', `Expected: ${expected}`);
                    DebugTerminal.log('debug', `Received: ${state}`);
                    
                    this.showError('Invalid state parameter. This could be a CSRF attack.', { 
                        received: state,
                        expected: expected
                    });
                    return;
                }
                
                if (state) {
                    DebugTerminal.log('success', 'âœ… State validation passed');
                }
                
                try {
                    DebugTerminal.log('info', 'ðŸ”„ Calling exchangeCodeForToken...');
                    const tokenData = await this.exchangeCodeForToken(code);
                    
                    DebugTerminal.log('debug', 'Token exchange returned:', tokenData);
                    
                    if (tokenData.access_token) {
                        DebugTerminal.log('success', 'ðŸŽ‰ ACCESS TOKEN OBTAINED SUCCESSFULLY!');
                        DebugTerminal.log('debug', `Token: ${tokenData.access_token.substring(0, 20)}...`);
                        this.showSuccess(tokenData.access_token, 'copilot');
                    } else if (tokenData.error) {
                        DebugTerminal.log('error', `âŒ Token data contains error: ${tokenData.error}`);
                        DebugTerminal.log('debug', `Error description: ${tokenData.error_description || 'none'}`);
                        this.showError(
                            tokenData.error_description || tokenData.error,
                            tokenData
                        );
                    } else {
                        DebugTerminal.log('error', 'âŒ Token data missing access_token');
                        this.showError(
                            'Failed to obtain access token',
                            tokenData
                        );
                    }
                } catch (error) {
                    DebugTerminal.log('error', `ðŸ’¥ Exception during token exchange: ${error.message}`);
                    DebugTerminal.log('debug', `Stack: ${error.stack}`);
                    this.showError(error.message, { 
                        code: code.substring(0, 10) + '...',
                        error: error.toString()
                    });
                }
            },

            // Main initialization
            async init() {
                DebugTerminal.log('info', 'ðŸš€ OAuth Callback Handler initializing...');
                DebugTerminal.log('debug', `Current URL: ${window.location.href}`);
                
                const params = this.getURLParams();
                DebugTerminal.log('debug', 'URL Parameters:', params);
                
                // Handle errors from GitHub
                if (params.error) {
                    DebugTerminal.log('error', `âŒ GitHub returned error: ${params.error}`);
                    DebugTerminal.log('debug', `Error description: ${params.error_description || 'none'}`);
                    this.showError(
                        params.error_description || params.error,
                        { error: params.error, description: params.error_description }
                    );
                    return;
                }
                
                // Handle implicit grant (token in URL hash)
                if (params.access_token) {
                    DebugTerminal.log('info', 'ðŸŽ« Implicit grant detected (token in URL)');
                    this.handleImplicitGrant(params.access_token, params.token_type);
                    return;
                }
                
                // Handle authorization code flow
                if (params.code) {
                    DebugTerminal.log('info', 'ðŸ”‘ Authorization code detected - starting code flow');
                    await this.handleCodeFlow(params.code, params.state);
                    return;
                }
                
                // No code or token found
                DebugTerminal.log('warning', 'âš ï¸  No authorization code or token found in URL');
                this.setState('no-code');
            }
        };

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            OAuthCallbackHandler.init();
        });

        // Handle messages from opener window (for token exchange)
        window.addEventListener('message', (event) => {
            // Verify origin for security
            if (!event.origin.includes('github.io') && !event.origin.includes('localhost')) {
                return;
            }
            
            if (event.data.type === 'CHECK_CALLBACK') {
                // Opener is checking if we're ready
                event.source.postMessage({ type: 'CALLBACK_READY' }, event.origin);
            }
        });
    </script>
</body>
</html>
